/* 1106. Lowest Price in Supply Chain (25) *//* 9:19 AM satrt *//* 9:55 AM 13/25 *//* 10:02 AM 25/25 Accepted! */#include<algorithm>#include<vector>#include<iostream>#include<cmath>#include<map>#include<queue>using namespace std;typedef struct Node{	int id;	int level;	bool isLeaf;}Node;vector<Node> vec;void bfs(vector<vector<int> > &graph){	queue<int> que;	vec[0].level=0;	que.push(0);	int cur;	while(!que.empty()){		cur=que.front();		for(int i=0;i<graph[cur].size();i++){			vec[graph[cur][i]].level=vec[cur].level+1;			que.push(graph[cur][i]);		}		que.pop();	}}bool cmp(const Node &a,const Node &b){	return a.level<b.level;}int main(){	freopen("D:\\in.txt","r",stdin);	int n;	double p,r;	scanf("%d%lf%lf",&n,&p,&r);	vec.resize(n);	vector<vector<int> > graph(n);	int temp;	for(int i=0;i<n;i++){		int k;		vec[i].id=i;		scanf("%d",&k);		if(k==0) vec[i].isLeaf=true;		else vec[i].isLeaf=false;		while(k--){			scanf("%d",&temp);			graph[i].push_back(temp);		}	}	bfs(graph);	sort(vec.begin(),vec.end(),cmp);	int minl;	int cnt=0;	bool flag=true;	for(int i=0;i<vec.size();i++){		if(vec[i].isLeaf&&flag){		   minl=vec[i].level;		   flag=false;		} 			if(vec[i].isLeaf&&!flag){		   if(vec[i].level==minl) cnt++;		   else if(vec[i].level!=minl) break;		}	}	printf("%.4f %d\n",p*pow((double)(1.0+r/100.0),minl),cnt);   return 0;	}
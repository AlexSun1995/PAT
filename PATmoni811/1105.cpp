 /* PAT 1105 Spiral Matrix */ /* the thinking of this piece of code */ /* is copied from the Internet */#include<iostream>#include<algorithm>#include<vector>#include<queue>#include<map>#include<cstring>#include<cmath>using namespace std;bool cmp(const int a,const int b){	return a>b;}int main(){	//freopen("D:\\in.txt","r",stdin);	int n;	int g[100][100];	scanf("%d",&n);	vector<int> vec;	vec.resize(n);    int col=(int)sqrt(double(n));	int m;	while(n%col!=0){		col--;	}	m=n/col;	for(int i=0;i<n;i++) scanf("%d",&vec[i]);	sort(vec.begin(),vec.end(),cmp);	memset(g,0,sizeof(g));	int dir[][2]={0,1,1,0,0,-1,-1,0};	int flag=0;	int x,y;	x=0;	y=-1;	/* it's really beautiful that the regularity */	/* can be explained in such a simple way. */	/* -->turn right--get down--turn left--get up--> */	/* and that's a circle. so we can using flag module 4*/	/* to stand for each situation one by one*/	/* notice that it's necessary to avoid seat which */	/* has already been taken  */	/* really a smart method. */	for(int i=0;i<vec.size();){ 		int ti=x+dir[flag][0];		int tj=y+dir[flag][1];		if(ti>=m||ti<0||tj>=col||tj<0||g[ti][tj]){			flag=(flag+1)%4;			continue;		}		g[ti][tj]=vec[i];		//cout<<"test ti:"<<ti<<" tj:"<<tj<<endl;		x=ti;		y=tj;		i++;	}	for(int i=0;i<m;i++){	    for(int j=0;j<col;j++){		   if(j==0) printf("%d",g[i][j]);           else printf(" %d",g[i][j]);		   		}		printf("\n");	}	return 0;}
/* 1107. Social Clusters (30) *//* starting time: 2016-8-11 10:09 AM*//* running for PAT! *//* ACCEPTED! 2016-8-11 11:25 */#include<algorithm>#include<vector>#include<iostream>#include<cmath>#include<map>#include<set>#include<queue>using namespace std;typedef struct Node{	int id;	int parent;}Node;vector<Node> fset;void initSet(){	for(int i=1;i<fset.size();i++){		fset[i].id=i;		fset[i].parent=i;	}}int Find(int a){	if(fset[a].parent!=a){		return fset[a].parent=Find(fset[a].parent);	}	else return fset[a].parent;}void setUnion(int root1,int root2){	int a=Find(root1);	int b=Find(root2);	fset[a].parent=b;}bool cmp(const Node &a,const Node &b){	return a.parent<b.parent;}bool cmp2(const int &a,const int &b){	return a>b;}int main(){   freopen("D:\\in.txt","r",stdin);   int n;   vector<vector<int> > hobby(1005);   scanf("%d",&n);   fset.resize(n+1);   initSet();   int temp;   for(int i=1;i<=n;i++){	   int k;	   scanf("%d:",&k);	   while(k--){		   scanf("%d",&temp);		   hobby[temp].push_back(i);	   }   }   for(int i=1;i<=1000;i++){	   if(hobby[i].size()==0) continue;	   else{		   for(int j=0;j<hobby[i].size();j++){			   setUnion(hobby[i][j],hobby[i][0]);		   }	   }   }   /*get result from the disjoint set */   for(int i=1;i<=fset.size();i++) fset[i].parent=Find(i);    fset[0].parent=99999;   sort(fset.begin(),fset.end(),cmp);   int cnt1=0;   int cnt2=0;   int cur=fset[0].parent;   vector<int> result;   for(int i=0;i<fset.size();i++){	   //cout<<"test-->fset[i].parent:"<<fset[i].parent<<endl;	   if(fset[i].parent==cur){		   cnt2++;	   }else{		   result.push_back(cnt2);		   cnt2=1;		   cur=fset[i].parent;		   cnt1++;	   }   }   sort(result.begin(),result.end(),cmp2);   printf("%d\n",cnt1);   printf("%d",result[0]);   for(int i=1;i<result.size();i++) printf(" %d",result[i]);   printf("\n");   return 0;	}
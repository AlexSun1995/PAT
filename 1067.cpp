/* 1067. Sort with Swap(0,*) (25) *//* 19/25 timeout */#include<vector>#include<algorithm>#include<iostream>#include<cstdio>#include<map>#include<set>using namespace std;typedef struct Node{	int key;	bool final;}Node;bool flag=true;void print(vector<Node> &vec){	for(int i=0;i<vec.size();i++)	printf("%d ",vec[i].key);	printf("\n");}int main(){	freopen("D:\\in.txt","r",stdin);	int n;	scanf("%d",&n);	vector<Node> vec(n);	for(int i=0;i<n;i++)	{	  scanf("%d",&vec[i].key);	  if(vec[i].key==i) vec[i].final=true;	  else vec[i].final=false;	}	int cnt=0;	for(int i=0;;)	{		flag=true;		if(vec[0].key!=0)	    {	    	int tmp=vec[0].key;	    	vec[0].key=vec[tmp].key;	    	vec[tmp].key=tmp;	    	cnt++;	    	//print(vec);		}		if(vec[0].key==0)		{			int pos;			for(int j=1;j<n;j++)			{				if(vec[j].key!=j)				{					flag=false;					pos=j;					break;				} 			}			if(flag) break;			else			{				int tmp=vec[i].key;				vec[i].final=false;				vec[i].key=vec[pos].key;				vec[pos].key=tmp;				cnt++;			}		}	}	printf("%d\n",cnt);	return 0;}/* ****************************** *//* get from CSDN */#include <stdio.h>  int findNotOK(int* arr,int begin,int end){  //从begin开始往后寻找未到位的数      for(int i=begin;i<end;i++){          if(arr[i]!=i)return i;      }      return 0;  }    int main(){      int n;      scanf("%d",&n);      int* arr = new int[n];      int i,t;      for(i=0;i<n;i++){          scanf("%d",&t);          arr[t]=i;      }      int tmp = 0;      int count=0;      int firstPos = 1;      firstPos = findNotOK(arr,firstPos,n);      while(firstPos){        //还有未到位的数字          if(arr[0]==0){      //如果0到位了，则与未到位的firstPos交换                 arr[0] = arr[firstPos];              arr[firstPos] = 0;              count++;          }          while(arr[0]!=0){   //如果0不到位，则循环与自己所指向的值交换              tmp = arr[0];              arr[0] = arr[tmp];              arr[tmp] = tmp;              count++;          }          firstPos = findNotOK(arr,firstPos,n);       //此时0归位了，找到下一个未到位的数字      }      printf("%d\n",count);      return 0;  }  
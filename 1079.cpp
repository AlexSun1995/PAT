/* 1079. Total Sales of Supply Chain (25) *//* 14:43 2016-9-1 *//*  20/25 2 points wrong answer 3 pointes timeout*//* if p,r is float ,20/25,if p.r is double 22/25 still 3 points timeout*//* too disgusting..*//* ZJU 2014 graduate exam*//* accepted! in  this case, Bfs is much more efficient than the dfs*//* pay attention: if there is a massive amount of input/output *//* using scanf/printf rather than cin/cout! */#include<iostream>#include<vector>#include<queue>#include<math.h>using  namespace std;typedef struct Node{	int parent;	vector<int> child;	int level;}Node;vector<Node>vec;void bfs(int root){	vec[root].level=0;	int cur;	queue<int> que;	que.push(root);	while(!que.empty())	{		cur=que.front();		for(int i=0;i<vec[cur].child.size();i++)		{			int w=vec[cur].child[i];			vec[w].level=vec[cur].level+1;			que.push(w);		}		que.pop();	}}int main(){	freopen("D:\\in.txt","r",stdin);	int n;	double p,r;	scanf("%d%lf%lf",&n,&p,&r);	vec.resize(n);	int num,v;	double s;	queue<pair<int,double> > que;	vec[0].parent=-1;	vec[0].level=0;	for(int i=0;i<n;i++)	{		scanf("%d",&num);		if(num==0)		{			scanf("%lf",&s);			que.push(make_pair(i,s));		}		while(num--)		{			scanf("%d",&v);			vec[i].child.push_back(v);		}	}	bfs(0);	double result=0.0;	while(!que.empty())	{		 pair<int,double> pa=que.front();		 int cur=pa.first;		 int cnt=0;		 /* if the data is massive,a lot of computing*/		 /* will be repeated,since all the paths will be*/		 /* found but one node may has lots of children! */		 // while(cur!=-1)		 // {		 //	cnt++;         //    cur=vec[cur].parent;					 // }		 cnt=vec[cur].level;		 que.pop();		 result+=(pa.second)*p*pow((double)(1+r/100.0),(double)(cnt));	}	printf("%.1lf",result);	return 0;}
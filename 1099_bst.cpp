/* PAT 1099 Build a Binary Search Tree *//* running for pat *//* 1.build the tree as ordered *//* 2.sort the sequence *//* 3.desing an algorithm to fill that tree *//* 2016-7-28 */#include<iostream>#include<vector>#include<queue>#include<algorithm>using namespace std;typedef struct Node{	int key;	int id;    int left;	int right;}Node;/* to store the layer traversal sequence */vector<int> result;int getChildSum(int id,vector<Node> &tree){	if(id==-1) return 0;	else{		return getChildSum(tree[id].left,tree)+getChildSum(tree[id].right,tree)+1;	}}void getHead(vector<int> &vec,int low,int high,vector<Node> &tree,int id){	if(id==-1) return;	if(low>high) return;	int child_lsum,child_rsum;	child_lsum=getChildSum(tree[id].left,tree);	child_rsum=getChildSum(tree[id].right,tree);	tree[id].key=vec[low+child_lsum];	getHead(vec,low,low+child_lsum-1,tree,tree[id].left);	getHead(vec,high-child_rsum+1,high,tree,tree[id].right);}void layerTraversal(vector<Node> &tree){	queue<int> que;	que.push(0);	while(!que.empty()){		int cur=que.front();		if(tree[cur].left!=-1){			que.push(tree[cur].left);		}		if(tree[cur].right!=-1){			que.push(tree[cur].right);		}		result.push_back(tree[cur].key);		que.pop();	}}int main(){	int n;	freopen("D:\\in.txt","r",stdin);	scanf("%d",&n);	vector<Node> tree(n);	vector<int> vec(n);	int left,right;	for(int i=0;i<n;i++){		scanf("%d%d",&left,&right);		tree[i].left=left;		tree[i].right=right;	}	for(int i=0;i<n;i++) scanf("%d",&vec[i]);	sort(vec.begin(),vec.end());	getHead(vec,0,n-1,tree,0);	layerTraversal(tree);	printf("%d",result[0]);	for(int i=1;i<result.size();i++){		printf(" %d",result[i]);	}	printf("\n");	return 0;}/* ********************************* *//* 2016-9-10 Accepted! *//* 1099. Build A Binary Search Tree (30) */#include<iostream>#include<vector>#include<algorithm>#include<queue>#include<map>#include<set>#define MS 200using namespace std;typedef struct  Node{	int key;	int left;	int right;}Node;vector<Node> vec(MS);int pos=0;vector<int> seq;int n;int getSum(int root){	if(root==-1) return 0;	else return getSum(vec[root].left)+getSum(vec[root].right)+1;}void buildTree(int left,int right,int root){	//cout<<"root: "<<root<<endl;	if(left<0||right>n-1||left>right||root==-1) return;	int ls=getSum(vec[root].left);	//int rs=getSum(vec[root].right);	buildTree(left,left+ls-1,vec[root].left);	vec[root].key=seq[pos];	//cout<<"root: "<<root<<" seq[pos]:"<<seq[pos]<<endl;	pos++;	buildTree(left+ls+1,right,vec[root].right);}void bfs(){	queue<int> que;	que.push(0);	bool first=true;	while(!que.empty())	{		int cur=que.front();		if(vec[cur].left!=-1) que.push(vec[cur].left);		if(vec[cur].right!=-1) que.push(vec[cur].right);		if(first)		{			printf("%d",vec[cur].key);			first=false;		}		else 		{			printf(" %d",vec[cur].key);		}		que.pop();	}	printf("\n");}int main(){	freopen("D:\\in.txt","r",stdin);	scanf("%d",&n);	seq.resize(n);	int lc,rc;	for(int i=0;i<n;i++)	{		scanf("%d%d",&lc,&rc);		vec[i].left=lc;		vec[i].right=rc;	}	for(int i=0;i<n;i++) scanf("%d",&seq[i]);	sort(seq.begin(),seq.end());	buildTree(0,n-1,0);	bfs();	return 0;}
/* PAT ID:1056 mice and Rice *//* Running for PAT! *//* 2016-07-18 12:59 PM *//* stopped at 2016-07-18 13:26 PM learning mathmatics... *//* AC time：2016-07-19 11:27 AM 我TM也是醉了。。 */#include<iostream>#include<stack>#include<vector>#include<queue>#include<map>#include<algorithm>using namespace std;typedef struct rank_node{	int id;	int layer;}rank_node;/* if the size of the order vector is 1,return true.*/int winner;bool comp(const rank_node &a,const rank_node &b){	return a.id<b.id;}bool judge_order(const vector<int> &a){	int count=0;	for(int i=0;i<a.size();i++){		if(a[i]!=-1){			count++;		winner=a[i];		//cout<<"the winner "<<winner<<endl;		}	}	if(count==1) return true;	else return false;}/* given a vector named vec_temp which stored the index of each member *//* of a group,and a vector named weight_vec is the weight information of all the  *//* member */int findGroupMax( vector<int> &vec_temp,const vector<int> &weight_vec){	int  max;	vector<int>::iterator iter=vec_temp.begin();	int max_index=*iter;	max=weight_vec[*iter];	for(;iter!=vec_temp.end();iter++){		if(weight_vec[*iter]>max){			max=weight_vec[*iter];			max_index=*iter;		}	}	return max_index;}int main(){	//freopen("D:\\in.txt","r",stdin);	vector<int> weight_vec;	vector<int> order;	map<int,int> myMap;	stack<rank_node> rank_sta;    	int n,m;	int stack_flag=1;	scanf("%d%d",&n,&m);	weight_vec.resize(n);	for(int i=0;i<n;i++) scanf("%d",&weight_vec[i]);	for(int i=0;i<n;i++){		int temp;		scanf("%d",&temp);		myMap.insert(make_pair(temp,i));		order.push_back(temp);	}	while(!judge_order(order)){		vector<int> vec_temp;		/* finding the max in a m-sized group and push it back to the queue*/		for(int i=0;i<order.size();i++){				if(order[i]!=-1&&vec_temp.size()!=m){				vec_temp.push_back(order[i]);				//printf("now we pushed: %d\n",weight_vec[order[i]]);			}			/* if we got m member or i is reaching the last element ,we need*/			/* to got the max weight mouce from that group. */			if(vec_temp.size()==m||(i==order.size()-1&&vec_temp.size()!=0)){				//printf("\n");				int max_index=findGroupMax(vec_temp,weight_vec);				//cout<<"we find vec_temp.size "<<vec_temp.size()<<endl;				//cout<<"we find max-index "<<max_index<<endl;				vector<int>::iterator iter=vec_temp.begin();				for(;iter!=vec_temp.end();iter++){					if(*iter!=max_index){						order[myMap[*iter]]=-1;						rank_node temp_node;						temp_node.id=*iter;						temp_node.layer=stack_flag;						rank_sta.push(temp_node);					}				}				vec_temp.clear();			}		} 		stack_flag++;	}	 judge_order(order);	 rank_node temp_node;	 temp_node.id=winner;	 //printf("the winner is: %d\n",winner);     temp_node.layer=stack_flag;	 rank_sta.push(temp_node);	/* test */	vector<rank_node> rank_vec;	rank_node temp_final;	while(!rank_sta.empty()){		rank_vec.push_back(rank_sta.top());		rank_sta.pop();	}	/* change the stack flag we set into real rank */	int  pre;	int final_rank = 1;	for(int i=0;i<rank_vec.size();i++){		if(i==0){			pre=rank_vec[i].layer;			rank_vec[i].layer=final_rank;		}		else if(rank_vec[i].layer<pre){			pre=rank_vec[i].layer;			rank_vec[i].layer=i+1;			final_rank=rank_vec[i].layer;		}		else if(rank_vec[i].layer==pre){			pre=rank_vec[i].layer;			rank_vec[i].layer=final_rank;		}		//printf("%d ",rank_vec[i].layer);	}	//printf("\n");	sort(rank_vec.begin(),rank_vec.end(),comp);	bool first=true;	for(int i=0;i<rank_vec.size();i++){		if(first){			printf("%d",rank_vec[i].layer);			first = false;		}		else{			printf(" %d",rank_vec[i].layer);		}	}	printf("\n");	return 0;}/* it's too complex of your version *//* the version below is quiet easy and smart than yours.*//* you must learn the thinking to easy your mind! */#include <iostream>#include <vector>#include <cstdio>using namespace std;int np, ng,rak[1005],mouse[1005];int main(){  cin >> np >> ng;  for (int i = 0; i < np; ++i)    scanf("%d",&mouse[i]);  vector<int> order;  for (int i = 0; i < np; ++i)  {    int tmp;    scanf("%d", &tmp);    order.push_back(tmp);  }  int rk = 0,npbak=np;  while (order.size()>1)  {    vector<int> order_;    for (int i = 0; i < order.size(); i += ng)    {      int mxe = order[i];      for (int j = 0; j < ng && i+j < order.size(); ++j)      {        if (mouse[order[i+j]]>mouse[mxe]) mxe = order[i+j];      }      order_.push_back(mxe);    }    for (int i = 0; i < order.size(); ++i)      rak[order[i]] = order_.size()+1;    order = order_;  }  rak[order[0]] = 1;  printf("%d",rak[0]);  for (int i = 1; i < npbak; ++i)    printf(" %d",rak[i]);  printf("\n");  system("pause");  return 0;}
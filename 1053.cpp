/* patID :1053 Path of Equal Weight *//* Starting time:2016-7-17  2:10 pm*//* Running for PAT! *//* Accepted! 30/30 2016-7-17 19:30 PM */#include<iostream>#include<vector>#include<stack>#include<queue>#include<algorithm>#include<cstring>using namespace std;typedef struct Node{	int id;	int weight;	vector<int> child;	int parent;	bool isLeaf;	long int totalWeight;}Node;/* sort vector, a little different, consider a vector as a whole *//* a element to sort. */bool comp(const vector<int> &a,const vector<int> &b){	int a_size=a.size();	int b_size=b.size();	int i,j;	for(i=0,j=0;i<a_size&&j<b_size;i++,j++){		if(a[i]>b[j]) return true;		else if(a[i]<b[j]) return false;	}	if(i==a_size&&j!=b_size) return false;	else if(i!=a_size&&j==b_size) return true;	else return false;}int main(){	freopen("D:\\in.txt","r",stdin);	vector<Node> Tree;	int n,m;	long int s;	scanf("%d%d%ld",&n,&m,&s);	Tree.resize(n);	for(int i=0;i<n;i++){		scanf("%d",&Tree[i].weight);		Tree[i].isLeaf=true;		Tree[i].totalWeight=0;	}	for(int i=0;i<m;i++){		int id,len,node;		scanf("%d%d",&id,&len);		Tree[id].isLeaf=false;		while(len--){			scanf("%d",&node);			Tree[id].child.push_back(node);			Tree[node].parent=id;		}	}		/* bfs to traverse the tree */		queue<int> que;		que.push(0);		Tree[0].parent=-1;		while(!que.empty()){			int cur=que.front();			if(cur==0) Tree[cur].totalWeight=Tree[cur].weight;			else {				Tree[cur].totalWeight=Tree[Tree[cur].parent].totalWeight+Tree[cur].weight;			}			/* get in all the children */			vector<int>::iterator iter;			for(iter=Tree[cur].child.begin();iter!=Tree[cur].child.end();iter++){				que.push(*iter);			}			que.pop();		}				/* find all the leaves that meet the stand and store them in a queue */		queue<int> last_leaf;		for(int i=0;i<n;i++){			if(Tree[i].isLeaf&&Tree[i].totalWeight==s) last_leaf.push(i);			else continue;		}        /* store the paths (which are a set a weight)*/		vector<int> paths[100];		stack<int> path_sta;		int index=0;		while(!last_leaf.empty()){			int cur=last_leaf.front();			while(cur!=-1){				path_sta.push(cur);				//cout<<"this is cur "<<cur<<endl;				cur=Tree[cur].parent;			}			while(!path_sta.empty()){				//cout<<"we see top "<<path_sta.top()<<endl;				paths[index].push_back(Tree[path_sta.top()].weight);				//cout<<"we see paths[i][j] "<<paths[index][j-1]<<endl; 				path_sta.pop();			}			index++;			last_leaf.pop();		}		/* this sort step is crucial  */		sort(paths,paths+index,comp);		for(int i=0;i<index;i++){			bool first=true;			 for(int j=0;j<paths[i].size();j++){				if(first){					printf("%d",paths[i][j]);					first=false;				} 				else printf(" %d",paths[i][j]);			 }			 printf("\n");		}    return 0;}
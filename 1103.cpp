/* 1103. Integer Factorization (30) *//* Sample Input 1: *//* 169 5 2 *//* Sample Output 1: *//* 169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2 *//* Sample Input 2: *//* 169 167 3 *//* Sample Output 2: *//* Impossible *//* this piece of code is copied from CSDN*//* using DFS search *//* this part remain a little misunderstanding. */#include <iostream>  #include <cstdio>  #include <cmath>  #include <vector>  #include <algorithm>  using namespace std;  typedef long long lint;  lint N,K;  int P;  lint lpower(lint n, lint p){      if(n == 1) return 1;      int factor = n;      for(int i = 1; i < p; i++) n *= factor;      return n;  }  vector<int> finalFactor;  int nowSum = 0;  bool dfs(lint N, int cur, vector<int>& factors){      if(cur == K){  	/*if they are many ways to get what we want */	/*such method is to define which is the best*/        if(N == 0){              int sum = 0;              for(int i = 0; i < factors.size(); i++){                  sum += factors[i];              }              if(sum >= nowSum){                  finalFactor = factors;                  nowSum = sum;              }              return true;          }else return false;      }      lint upper = sqrt((double)N);   	/* the search is in a none-decresing order */    lint lower = cur > 0 ? factors[cur - 1] : 1;      for(lint i = lower; i <= upper; i++){          lint res = lpower(i,P);          if(N >= res){              factors[cur] = i;              dfs(N-res,cur+1,factors);          }else{              return false;          }      }      return true;  }  int main()  {      cin >> N >> K >> P;      vector<int> factors(K);      dfs(N,0,factors);      reverse(finalFactor.begin(),finalFactor.end());      if(finalFactor.size() == K){          printf("%d = ",N);          printf("%d^%d",finalFactor[0],P);          for(int i = 1; i < finalFactor.size(); i++){              printf(" + %d^%d",finalFactor[i],P);          }      }else{          cout << "Impossible";      }      cout << endl;      return 0;  }  
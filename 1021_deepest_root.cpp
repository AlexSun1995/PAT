/* Deepest Root patID:1021  *//* how to find circle in a graph....? *//* using bfs() to count the deepest level... done... *//* 16/25 you just do one thing, a lot remain to do *//* you aim to detect the circle using dfs,but this part is totally wrong.*//* they only want you to find out the num of  components e......let me go die*/#include<iostream>#include<vector>#include<queue>#include<map>#include<algorithm>#define MAX 10000using namespace std;bool visited[MAX];bool hasCircle;int lastVisited;typedef struct myMap{	  int id;	  int level;}myMap;bool myComp(const myMap &a,const myMap &b){	if(a.level!=b.level) return a.level>b.level;	else return a.id<b.id;}void clean(int n){	 for(int i=0;i<=n;i++) visited[i]=false;}/* deep first seach, test to find whether has a circle *//* NOT NECESSARY... */int kt,k;void dfs(vector<int> *graph,int index){     vector<int>::iterator iter = graph[index].begin();	 visited[index]=true;     for(;iter!=graph[index].end();iter++){		 if(!visited[*iter]){			 lastVisited=*iter;			 kt++;		    dfs(graph,*iter);  		 }		 else if(visited[*iter]&&(*iter)!=lastVisited){			k+=kt;            kt=0;					 }    	 }	 }int bfs(vector<int> *graph,int index){	int levelCount=0;	int numEachLevel=0;	queue<int> que;	que.push(index);	numEachLevel++;	while(!que.empty()){	    vector<int>::iterator iter=graph[que.front()].begin();		while(iter!=graph[que.front()].end()){  			if(!visited[*iter]){		     que.push(*iter);			 visited[*iter]=true;			}			 iter++;		} 		que.pop();		numEachLevel--;		if(numEachLevel==0){ 			levelCount++;		//cout<<"levelCount "<<levelCount<<endl;           numEachLevel=que.size();        }			}		 return levelCount;}int main(){	 int n;	 freopen("D:\\in.txt","r",stdin);	 scanf("%d",&n);	 kt=k=0;	 vector<myMap> result;	 myMap temp;	 vector<int> *graph=new vector<int>[n+1];	 int node1,node2;	 for(int i=1;i<=n;i++){		 scanf("%d%d",&node1,&node2);		 graph[node1].push_back(node2);		 graph[node2].push_back(node1);	 }	 clean(n);	 dfs(graph,1);	 if(k!=0){		 printf("Error: %d components\n",k);		 return 0;	 }	 for(int i=1;i<=n;i++){		clean(n);		temp.id=i;		temp.level=bfs(graph,i);        result.push_back(temp);			 }	 sort(result.begin(),result.end(),myComp);	 vector<myMap>::iterator iter=result.begin();	 int maxLevel=iter->level;	 for(;iter!=result.end();iter++){			  if(iter->level!=maxLevel) break;		  else  cout<<(iter->id)<<endl; 	 }	 return 0;}/**********************************************baigui Sun from CSDN seach of tree, union-find set*********************************************/#include<iostream>  #include<vector>  #include<algorithm>  #include<queue>  #include<set>  //#include<_dbdao.h>  std::vector<bool> visited;  std::vector<int> step;  std::vector<std::vector<int>> edge;  std::vector<int> p;  int n;  int BFS(int s)  {      visited.assign(n+1, false);      std::queue<int> q;      q.push(s);      visited[s] = true;      int cnt = 1;//      step.assign(n+1, 0);      step[s] = 1;      int mmax = step[s];      while(!q.empty())      {          int c = q.front();          q.pop();          for(int i = 0; i < edge[c].size(); ++i)          {              int index = edge[c][i];               if(!visited[index])              {                  q.push(index);                  step[index] = step[c]+1;                  mmax = std::max(step[index], mmax);                  visited[index] = true;                  cnt++;                  if(cnt == n) break;              }          }      }      return mmax;  }  void InitSet()  {      p.resize(n+1);      for(int i = 0; i < p.size(); ++i)          p[i] = i;  }  void CompressSet(int top, int x)  {      if(p[x] != top)      {          CompressSet(top, p[x]);//go to root          p[x] = top;//when root back, then assign to top      }  }  int FindSet(int x)  {      if(x != p[x])      {          int t = FindSet(p[x]);//go to root          CompressSet(t, x);//when root back, then compress      }      return p[x];  }  void UnionSet(int x, int y)  {      int a = FindSet(x);      int b = FindSet(y);      p[a] = b;  }  int main()  {      while(scanf("%d",&n)!=EOF)      {          edge.clear();          edge.resize(n+1);          for(int i = 1; i <= n-1; ++i)          {              int a, b;              scanf("%d%d",&a,&b);              edge[a].push_back(b);              edge[b].push_back(a);          }          //check if it is a tree          //construct disjoint set          InitSet();          for(int i = 1; i <= n; ++i)          {              for(int j = 0; j < edge[i].size(); ++j)              {                  UnionSet(i, edge[i][j]);              }          }          std::set<int> root;          for(int i = 1; i <= n; ++i)              root.insert(FindSet(i));          if(root.size() != 1)              printf("Error: %d components\n",root.size());          else          {              //bfs              //get one endpoint first              std::set<int> ans;              int mmax = BFS(1);              for(int i = 1; i <= n; ++i)                  if(step[i] == mmax) ans.insert(i);              //get the diameter of the tree              mmax = BFS(*ans.begin());              for(int i = 1; i <= n; ++i)                  if(step[i] == mmax) ans.insert(i);              //output              std::set<int>::iterator it;              for(it = ans.begin(); it != ans.end(); it++)                  printf("%d\n",*it);          }        }      return 0;  }  /*****************************************version 3 myself T I M U !  23/25****************************************//* Deepest Root patID:1021  *//* how to find circle in a graph....? *//* using bfs() to count the deepest level... done... *//* 23/25 */#include<iostream>#include<vector>#include<queue>#include<map>#include<set>#include<algorithm>#define MAX 10000using namespace std;bool visited[MAX];bool hasCircle;int lastVisited;vector<int> p;/* some operation of Find-Union Set*/void initSet(int n){	p.resize(n+1);	for(int i=1;i<p.size();i++)		p[i]=i;}void compress(int top,int x){	 if(p[x]!=top){		 compress(top,p[x]);  // i think there is a little extra, right?		 p[x]=top;	 }}int findSet(int x){	if(p[x]!=x){		int t = findSet(p[x]);  //t is the root		compress(t,x);  // make t the dirtct parent of x.	}		return p[x];}void unionSet(int x,int y){	int a,b;    a=findSet(x);    b=findSet(y);    p[a]=b;	}typedef struct myMap{	  int id;	  int level;}myMap;bool myComp(const myMap &a,const myMap &b){	if(a.level!=b.level) return a.level>b.level;	else return a.id<b.id;}void clean(int n){	 for(int i=0;i<=n;i++) visited[i]=false;}int bfs(vector<int> *graph,int index){	int levelCount=0;	int numEachLevel=0;	queue<int> que;	que.push(index);	numEachLevel++;	while(!que.empty()){	    vector<int>::iterator iter=graph[que.front()].begin();		while(iter!=graph[que.front()].end()){  			if(!visited[*iter]){		     que.push(*iter);			 visited[*iter]=true;			} 			 iter++;		} 		que.pop();		numEachLevel--;		if(numEachLevel==0){ 			levelCount++;		//cout<<"levelCount "<<levelCount<<endl;           numEachLevel=que.size();        }			}		 return levelCount;}int main(){	 int n;	// freopen("D:\\in.txt","r",stdin);	 scanf("%d",&n);	 vector<myMap> result;	 myMap temp;	 vector<int> *graph=new vector<int>[n+1];	 int node1,node2;	 for(int i=1;i<=n;i++){		 scanf("%d%d",&node1,&node2);		 graph[node1].push_back(node2);		 graph[node2].push_back(node1);	 }	  initSet(n);	   for(int i=1;i<=n;i++){		    for(int j=0;j<graph[i].size();j++)				unionSet(i,graph[i][j]);	   }	     	   set<int> root;	   for(int i=1;i<=n;i++){		    root.insert(findSet(i));  	   }	   if(root.size()!=1){		   printf("Error: %d components",root.size());		   return 0;	   }	 for(int i=1;i<=n;i++){		clean(n);		temp.id=i;		temp.level=bfs(graph,i);        result.push_back(temp);			 }	 sort(result.begin(),result.end(),myComp);	 vector<myMap>::iterator iter=result.begin();	 int maxLevel=iter->level;	 for(;iter!=result.end();iter++){			  if(iter->level!=maxLevel) break;		  else  cout<<(iter->id)<<endl; 	 }	 return 0;}/* 2016 9-9 version Accepted! *//* using union-find (disjointed set) and dfs *///deepest tree 2016-9-9 14:50 // 15:49 20/25  //16:10 Accepted! be carefull!!!#include<iostream>#include<vector>#include<algorithm>#include<set>#include<queue>#define MS 10005using namespace std;typedef struct Node{  	int parent;  	bool visited;  	int len;}Node;vector<vector<int> >mmap(MS);vector<Node> vec(MS);priority_queue<int> que;int maxl=0;int n;void init(){	for(int i=1;i<=n;i++)	{		vec[i].parent=i;		vec[i].visited=false;		vec[i].len=1;	}}void init2(){	for(int i=1;i<=n;i++) vec[i].visited=false;}int Find(int a){	if(vec[a].parent!=a)	  return vec[a].parent=Find(vec[a].parent);	else return a;}void Union(int a,int b){	int x=Find(a);	int y=Find(b);	vec[x].parent=y;}int dfs(int i,int sum){    if(sum>maxl) maxl=sum;	int w;	for(int t=0;t<mmap[i].size();t++)	{		w=mmap[i][t];		if(!vec[w].visited)		{		    vec[w].visited=true;		    dfs(w,sum+1);		    vec[w].visited=false;		}	}}int main(){	freopen("D:\\in.txt","r",stdin);	scanf("%d",&n);	int from,to;	init();	//mark <= not <!!!!	for(int i=1;i<=n;i++)	{		scanf("%d%d",&from,&to);		mmap[from].push_back(to);		mmap[to].push_back(from);		Union(from,to);    }    int com=0;    set<int> par;    for(int i=1;i<=n;i++)    {    	par.insert(Find(i));	}	if(par.size()>1)	{		printf("Error: %d components\n",par.size());	}	else{		int dsp=-1;		int cur;		set<int> res;		for(int i=1;i<=n;i++)		{			maxl=0;			init2();			vec[i].visited=true;			dfs(i,0);			cur=maxl;			if(cur>dsp)			{				dsp=cur;				res.clear();				res.insert(i);			}			else if(cur==dsp)			{				res.insert(i);			}		}		set<int>::iterator iter;		for(iter=res.begin();iter!=res.end();iter++) printf("%d\n",*iter);	}     return 0;}
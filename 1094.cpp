/* 1094. The Largest Generation (25) *//* starting at 2016-8-15 19:48*//* accepted at 20:31 *//* the construct of a map, relearn.. */#include<iostream>#include<vector>#include<string>#include<algorithm>#include<set>#include<map>#include<queue>using namespace std;typedef struct Node{ 	int level;	vector<int> child;}Node;vector<int> result;map<int,int> map1;void bfs(vector<Node> &vec){	vec[1].level=1;	queue<int> que;	que.push(1);	map1[1]=1;	int cur;	while(!que.empty()){		cur=que.front();		if(vec[cur].child.size()!=0)		{			for(int i=0;i<vec[cur].child.size();i++)			{				vec[vec[cur].child[i]].level=vec[cur].level+1;				map1[vec[cur].level+1]++;				que.push(vec[cur].child[i]);			}		}		que.pop();	}}int main(){	//freopen("D:\\in.txt","r",stdin);	int n,m,k,t,id;	vector<Node> vec;	scanf("%d%d",&n,&m);    vec.resize(n+1);	for(int i=0;i<m;i++){	    scanf("%d",&id);	    scanf("%d",&k);		while(k--){			scanf("%d",&t);			vec[id].child.push_back(t);		}	}	bfs(vec);	map<int,int>::iterator iter;	int max=-1;	int key;	for(iter=map1.begin();iter!=map1.end();iter++)	{		if(iter->second>max){			max=iter->second;			key=iter->first;		}	}	cout<<max<<" "<<key<<endl;    return 0;}
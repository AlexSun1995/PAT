/* PAT 1109 Group Photos*//* 17/25 */#include<iostream>#include<vector>#include<string>#include<queue>#include<algorithm>using namespace std;typedef struct People{	int height;	string name;}People;typedef struct Position{	string name;	int line;	int height;	int posInLine;}Position;bool cmp(const People &a,const People &b){	if(a.height!=b.height){		return a.height<b.height;	}	else{		return a.name<b.name;	}}bool cmp2(const Position &a,const Position &b){	if(a.line!=b.line){		return a.line>b.line;	}	else{		return a.posInLine<b.posInLine;	}}bool cmp3(const Position &a,const Position &b){	if(a.height!=b.height){		return a.height>b.height;	}	else return a.name<b.name;}int main(){	freopen("D:\\in.txt","r",stdin);	int n,k;	int perLine;	scanf("%d%d",&n,&k);	vector<People> vec(n);	vector<Position> pos;	perLine=n/k;    for(int i=0;i<n;i++){		cin>>vec[i].name;		scanf("%d",&vec[i].height);	}	sort(vec.begin(),vec.end(),cmp);	int count=0;	int lineCount=k;	Position temp;	int i;	int sumLastLine=k;  //total amount of people in the last line    for(i=k*perLine-1;i>=0;i--){		if(count==perLine){			lineCount--;			count=0;		}		count++;		temp.name=vec[i].name;		temp.height=vec[i].height;		temp.line=lineCount;		pos.push_back(temp);	}	i=k*perLine;	while(i<vec.size()){		temp.name=vec[i].name;		temp.line=k;		temp.height=vec[i].height;		sumLastLine++;		i++;		pos.push_back(temp);	}	sort(pos.begin(),pos.end(),cmp3);	//for(int i=0;i<pos.size();i++) cout<<"**"<<pos[i].name<<"$$"<<pos[i].line<<endl;	for(int t=0;t<pos.size();){		/* the last line,we treat differently*/		if(pos[t].line==k){			pos[t].posInLine=1+(sumLastLine/2);			int left,right;			left=pos[t].posInLine-1;			right=pos[t].posInLine+1;			for(int i=1;i<sumLastLine;i++){				if(i%2==1){					pos[t+i].posInLine=left;					left--;				}				else{					pos[t+i].posInLine=right;					right++;				}			}			t+=sumLastLine;		}		else{			pos[t].posInLine=1+(perLine/2);			int left,right;			left=pos[t].posInLine-1;			right=pos[t].posInLine+1;			for(int i=1;i<perLine;i++){				if(i%2==1){					pos[t+i].posInLine=left;					left--;				}				else{					pos[t+i].posInLine=right;					right++;				}			}			t+=perLine;		}	}	sort(pos.begin(),pos.end(),cmp2);	vector<Position>::iterator iter=pos.begin();	int cur_line = k;	bool firstFlag=true;	for(;iter!=pos.end();iter++){		if(iter->line!=cur_line){			firstFlag=true;			cur_line=iter->line;			cout<<endl;		}		if(firstFlag){			cout<<iter->name;			firstFlag=false;		}		else cout<<" "<<iter->name;	}	return 0;}/* ****************************************** *//* PAT 1109 Group Photos*//* 17/25 *//* version 2 tag,interior tag,sort.. *//* 20/25 reason unknown.. */#include<iostream>#include<vector>#include<string>#include<queue>#include<algorithm>using namespace std;typedef struct People{	int height;	string name;}People;typedef struct Position{	string name;	int line;	int height;	int posInLine;}Position;bool cmp(const People &a,const People &b){	if(a.height!=b.height){		return a.height<b.height;	}	else{		return a.name<b.name;	}}bool cmp2(const Position &a,const Position &b){	if(a.line!=b.line){		return a.line>b.line;	}	else{		return a.posInLine<b.posInLine;	}}bool cmp3(const Position &a,const Position &b){	if(a.height!=b.height){		return a.height>b.height;	}	else return a.name<b.name;}int main(){	freopen("D:\\in.txt","r",stdin);	int n,k;	int perLine;	scanf("%d%d",&n,&k);	vector<People> vec(n);	vector<Position> pos;	perLine=n/k;    for(int i=0;i<n;i++){		cin>>vec[i].name;		scanf("%d",&vec[i].height);	}	sort(vec.begin(),vec.end(),cmp);	int count=0;	int lineCount=k-1;	Position temp;	int i;	int sumLastLine=0;  //total amount of people in the last line    for(i=(k-1)*perLine-1;i>=0;i--){		if(count==perLine){			lineCount--;			count=0;		}		count++;		temp.name=vec[i].name;		temp.height=vec[i].height;		temp.line=lineCount;		pos.push_back(temp);	}	i=(k-1)*perLine;	while(i<vec.size()){		temp.name=vec[i].name;		temp.line=k;		temp.height=vec[i].height;		sumLastLine++;		i++;		pos.push_back(temp);	}	sort(pos.begin(),pos.end(),cmp3);	//for(int i=0;i<pos.size();i++) cout<<"**"<<pos[i].name<<"$$"<<pos[i].line<<endl;	for(int t=0;t<pos.size();){		/* the last line,we treat differently*/		if(pos[t].line==k){			pos[t].posInLine=1+(sumLastLine/2);			int left,right;			left=pos[t].posInLine-1;			right=pos[t].posInLine+1;			for(int i=1;i<sumLastLine;i++){				if(i%2==1){					pos[t+i].posInLine=left;					left--;				}				else{					pos[t+i].posInLine=right;					right++;				}			}			t+=sumLastLine;		}		else{			pos[t].posInLine=1+(perLine/2);			int left,right;			left=pos[t].posInLine-1;			right=pos[t].posInLine+1;			for(int i=1;i<perLine;i++){				if(i%2==1){					pos[t+i].posInLine=left;					left--;				}				else{					pos[t+i].posInLine=right;					right++;				}			}			t+=perLine;		}	}	sort(pos.begin(),pos.end(),cmp2);	vector<Position>::iterator iter=pos.begin();	int cur_line = k;	bool firstFlag=true;	for(;iter!=pos.end();iter++){		if(iter->line!=cur_line){			firstFlag=true;			cur_line=iter->line;			cout<<endl;		}		if(firstFlag){			cout<<iter->name;			firstFlag=false;		}		else cout<<" "<<iter->name;	}	return 0;}/* God version... from CSDN  ACED*/#include<iostream>#include<stdio.h>#include<math.h>#include<string.h>#include<vector>#include<list>#include<algorithm>using namespace std;#define MAX 20012struct node{	char name[11];	int h;	bool operator >(const node& t)const{		if(h==t.h){			return strcmp(t.name,name)>0?true:false;		}		return h>t.h;	}};node a[MAX];int main(){	int N,K;	scanf("%d%d",&N,&K);	for(int i=0;i<N;i++){		scanf("%s%d",a[i].name,&a[i].h);	}	sort(a,a+N,greater<node>());	int n,m;		n = K;//四舍五入	int fr = N/K+N%K;		int time = 0;	vector<int> v[K];	//直接插入 	for(int i=0;i<n;i++){			for(int j=0;j<fr;j++){				if(j%2){	//为奇数则插入左面 					v[i].insert(v[i].begin(),time);				}				else{	//偶数插最后 					v[i].push_back(time);				}				time++;			}		fr = N/K;	//只需要特殊判最上面一行 	}	for(int i=0;i<n;i++){	//vector输出，无需判断 			for(int j=0;j<v[i].size();j++){				printf("%s",a[v[i][j]].name);				if(j!=v[i].size()-1)	printf(" ");				else printf("\n");			}			}	return 0;}/* Learning The Version above and rewrite by myself *//* by recording the appearing sequence can avoid  *//* too many sort operate, this is much more smart  *//* and simple than the initial version by your own */#include<iostream>#include<vector>#include<string>#include<queue>#include<algorithm>using namespace std;typedef struct People{	int height;	string name;}People;bool cmp(const People &a,const People &b){	if(a.height!=b.height){		return a.height>b.height;	}	else{		return a.name<b.name;	}}int main(){	freopen("D:\\in.txt","r",stdin);	int n,k;	int perLine;	scanf("%d%d",&n,&k);	vector<People> vec(n);	perLine=n/k;    for(int i=0;i<n;i++){ 		cin>>vec[i].name;		scanf("%d",&vec[i].height);	}	sort(vec.begin(),vec.end(),cmp);	int sr = n/k + n%k;    // sum of a row	int time=0;	int row;	vector<int> seq[k];	for(int i=0;i<k;i++){		for(int j=0;j<sr;j++){			if(j%2==1){			  seq[i].insert(seq[i].begin(),time); 				}			else seq[i].push_back(time);		    time++;			}		sr=n/k;    }	for(int i=0;i<k;i++){		for(int j=0;j<seq[i].size();j++){			cout<<vec[seq[i][j]].name;			if(j!=seq[i].size()-1) printf(" ");			else printf("\n");		}	}	return 0;} 
/* Quene at Bank *//* starting time: 2016-06-06 11:10*//* submit time: 2016-06-06 13:40 25/25 Accepted! *//* the thinking is very inportant */#include<iostream>#include<queue>#include<vector>#include<algorithm>using namespace std;typedef struct custom{	int hour,min,sec;	int process;	int total;	int serveTime;}custom;bool comp(const custom &a,const custom &b){	 return a.total<b.total;}int main(){	//freopen("D:\\in.txt","r",stdin);	int N,K;  // num of customs; num of windows	cin>>N>>K;	custom temp;	vector<custom> vec;	/* input */	while(N--){		scanf("%d:%d:%d",&temp.hour,&temp.min,&temp.sec);		scanf("%d",&temp.process);		temp.total=60*60*temp.hour+60*temp.min+temp.sec;		vec.push_back(temp);	}	/* sort by arrival time.. */	sort(vec.begin(),vec.end(),comp);	/* can be described as the nearest time that each window can provide service. */	int *eachWindowTimeLine=new int[K];	bool *serving=new bool[K];	for(int i=0;i<K;i++) {		eachWindowTimeLine[i]=8*60*60;		serving[i]=false;	}	vector<custom>::iterator iter=vec.begin();	int countNum=0;	int totalWaitig=0;	bool firstTime=false;	for(;iter!=vec.end();iter++){		//those who come later than 17:00 will be ignored		if(iter->total<=17*60*60){			countNum++;			int minTime=eachWindowTimeLine[0];            int minIndex=0;			 for(int i=0;i<K;i++)			 { 		         if(eachWindowTimeLine[i]<minTime){					 minTime=eachWindowTimeLine[i];					 minIndex=i;				 }			 }			 //must wait			 /* the nearest time to serve is later than the coming moment. */			 /* in that case, you must wait. */			 if(minTime>(iter->total)){				totalWaitig+=minTime-(iter->total);				eachWindowTimeLine[minIndex]+=60*(iter->process);			 }			 /* the nearest time to serve is earlier than the coming moment */			 /* that means the window has been vacant for some time,and of course the  */			 /* window can provide service immediately,and the latest service time that window*/			 /* should be updated. */			 else if(minTime<=iter->total){				totalWaitig+=0;                eachWindowTimeLine[minIndex]=iter->total;		        eachWindowTimeLine[minIndex]+=60*(iter->process);					 }		}	}	printf("%.1f",(float)totalWaitig/(countNum*60));	return 0;}
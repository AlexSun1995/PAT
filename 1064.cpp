/* 1064. Complete Binary Search Tree (30) *//* Accepted! 30/30 2016-8-31 10:37 *//* 1.expecially ahout the deepth of a CBT *//* 2.think about the boundary situation. *//* this piece of code is very beautiful. *//* the beauty lies in the art of recursion*//******************************************Sample Input:101 2 3 4 5 6 7 8 9 0Sample Output:6 3 8 1 5 7 9 0 2 4****************************************** */#include<iostream>#include<algorithm>#include<vector>#include<cmath>#include<queue>using namespace std;int dex=1;int n;typedef struct Node{     int key;     Node *left;	 Node *right;}Node;typedef struct Situation{	bool leftFull;	bool rightFull;	int maxLevel;}Situation;vector<int> vec;Node *root;bool firstNode=true;int getNodes(int level){	if(level<=0) return 0;	int total=1;	for(int i=1;i<=level;i++) total*=2;	return total-1;}Situation getHeight(int size){  	Situation sit;	int i=0;	int cur=0;	while(cur<size)	{		cur=(int)pow((double)2,(double)(i+1))-1;		i++;	}	if(cur==size)	{		sit.leftFull=true;		sit.rightFull=true;	}	else if(cur>size)	{		if(getNodes(i-1)+getNodes(i-2)+1>=size)		{			sit.leftFull=false;			sit.rightFull=true;		}		else if(getNodes(i-1)+getNodes(i-2)+1<size)		{			sit.leftFull=true;			sit.rightFull=false;		}	}	sit.maxLevel=i;	return sit;}Node *buildTree(int left,int right){	cout<<"building tree..."<<"left:"<<left<<" right:"<<right<<endl;	if(right<left||left<0||right>n) return NULL;	Node *node=(Node *)malloc(sizeof(Node));	int n=right-left+1;	Situation sit=getHeight(n);	int rightSize;	int leftSize;	int pivot;	if(sit.leftFull==true&&sit.rightFull==true)	{		rightSize=getNodes(sit.maxLevel-1);		pivot=right-rightSize;	}	else if(sit.leftFull==true&&sit.rightFull==false)	{		leftSize=getNodes(sit.maxLevel-1);		pivot=left+leftSize;	}	else if(sit.leftFull==false&&sit.rightFull==true)	{		rightSize=getNodes(sit.maxLevel-2);		pivot=right-rightSize;	}	node->key=vec[pivot];	node->left=buildTree(left,pivot-1);	node->right=buildTree(pivot+1,right);	return node;}void levelTraversal(Node *root){    queue<Node *> que;	que.push(root);	bool firstPrint=true;	while(!que.empty())	{		Node *cur=que.front();		if(firstPrint){			printf("%d",cur->key);			firstPrint=false;		}		else{			printf(" %d",cur->key);		}		if(cur->left) que.push(cur->left);		if(cur->right) que.push(cur->right);		que.pop();	}}int main(){	freopen("D:\\in.txt","r",stdin);	cin>>n;    	vec.resize(n);	for(int i=0;i<n;i++)	{	 scanf("%d",&vec[i]);	}	sort(vec.begin(),vec.end());	root=buildTree(0,n-1);	levelTraversal(root);	return 0;}/* a very simple and beautiful version. *//* a BST must meet such rules: *//* one node's left child = 2 * thisNode *//* one node's right child = 2 * thisNode + 1 *//* very very beautiful! and much more simple. */#include <iostream>#include <cstdio>#include <algorithm>using namespace std;const int N = 1005;int nod[N], tree[N], pos, root;int n;void build(int root){  if (root > n) return;  int l = root << 1, r = (root << 1) + 1;// left=node*2,right=node*2+1  build(l);  /* it can make sure that left side smaller and right side larger. */  tree[root] = nod[pos++];  build(r);}int main(){  cin >> n;  for(int i = 0; i < n; ++i)    scanf("%d", &nod[i]);  sort(nod,nod+n);  build(1);  cout << tree[1];  for (int i = 2; i <= n; ++i)    printf(" %d",tree[i]);  cout << endl;  system("pause");  return 0;}
//1003. Emergency (25)  using dijkstra only/* first submit 2016-9-9 13:43  22/25 wrong answer*//* 25/25  14:13 *//* running for PAT! */#include<iostream>#include<vector>#include<algorithm>#include<map>#define INF 0x7fffffff#define MS 510using namespace std;typedef struct Node{	bool visited;	int teams;	int tdis;	int tm;	int num;}Node;typedef struct Edge{	int id;	int dis;	Edge(int _id,int _dis)	{		id=_id;		dis=_dis;	}}Edge;vector<Node> vec(MS);vector<vector<Edge> >mmap(MS);vector<int> memb(MS);int mindis=INF;int n,m,s,d;int cnt=0;int maxr=0;void init(){	for(int i=0;i<n;i++)	{		vec[i].visited=false;		vec[i].tdis=INF;		vec[i].tm=-1;		vec[i].num=0;	}}int findShortest(){	int mini=-1;	int min;	bool flag=false;	for(int i=0;i<n;i++)	{		if(!flag&&!vec[i].visited)		{			flag=true;			min=vec[i].tdis;			mini=i;		}		else if(flag&&!vec[i].visited&&vec[i].tdis<min)		{			min=vec[i].tdis;			mini=i;		}	}	return mini;}int dijk(int start,int des){	int v,w;	vec[start].tdis=0;	vec[start].tm=memb[start];	vec[start].num=1;	while(true)	{		v=findShortest();		if(v==-1||v==des) break;		vec[v].visited=true;		for(int i=0;i<mmap[v].size();i++)		{			w=mmap[v][i].id;			if(vec[w].visited) continue;			if(vec[w].tdis>vec[v].tdis+mmap[v][i].dis)			{				vec[w].tdis=vec[v].tdis+mmap[v][i].dis;				vec[w].num=vec[v].num;				vec[w].tm=vec[v].tm+memb[w];			}			else if(vec[w].tdis==vec[v].tdis+mmap[v][i].dis)			{				/* mark  logical problem */				vec[w].num+=vec[v].num;				if(vec[w].tm<vec[v].tm+memb[w])				{					vec[w].tm=vec[v].tm+memb[w];				}			}		}	}	return vec[des].tdis;  }int main(){	freopen("D:\\in.txt","r",stdin);    scanf("%d%d%d%d",&n,&m,&s,&d);	for(int i=0;i<n;i++) scanf("%d",&memb[i]);	int from,to,dis; 	while(m--)	{		scanf("%d%d%d",&from,&to,&dis);		mmap[from].push_back(Edge(to,dis));		mmap[to].push_back(Edge(from,dis));	}	init();    dijk(s,d);    printf("%d ",vec[d].num);    printf("%d\n",vec[d].tm);	return 0;	}
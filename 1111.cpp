/* PAT 1111 Online Map *//* starting at 2016-8-4 23:01 *//* double use of Dijkstra's algorithm 27/30*//* when you face the indentical weight,how to choose the best *//* the work amount is tremendous... */#include<iostream>#include<cstdio>#include<queue>#include<vector>#include<stack>#define INFI 99999using namespace std;typedef struct Edge{	int id;	int time;	int length;}Edge;typedef struct Node{	int timeCost;	int totalDis;	int numNodes;	bool visited;}Node;vector<vector<Edge> > graph;vector<Node> vec_Node;vector<int> path;vector<int> timePath;void initNode(){	for(int i=0;i<vec_Node.size();i++)	{		vec_Node[i].timeCost=INFI;		vec_Node[i].totalDis=INFI;		vec_Node[i].visited=false;	}}int findUnVisitedBest(){	bool firstCmp=true;	int minDis=-1;	int minV=-1;	for(int i=0;i<vec_Node.size();i++){		if(vec_Node[i].visited==false&&firstCmp){			firstCmp=false;			minDis=vec_Node[i].totalDis;			minV=i;		}		else if(vec_Node[i].visited==false&&vec_Node[i].totalDis<minDis){			minDis=vec_Node[i].totalDis;			minV=i;		}	}	return minV;}void findShortestPath(int start,int end){	int v=start;	int w;	vec_Node[v].timeCost=0;	vec_Node[v].totalDis=0;	while(true){		v=findUnVisitedBest();		if(v==-1){			break;		}		vec_Node[v].visited=true;		/* update all the nodes' infromation that adjacent to v */        for(int i=0;i<graph[v].size();i++){			int cur_id=graph[v][i].id;			int flag=false;			if(vec_Node[cur_id].timeCost>vec_Node[v].timeCost+graph[v][i].time){				vec_Node[cur_id].timeCost=vec_Node[v].timeCost+graph[v][i].time;				flag=true;			}			if(vec_Node[cur_id].totalDis>vec_Node[v].totalDis+graph[v][i].length){				vec_Node[cur_id].totalDis=vec_Node[v].totalDis+graph[v][i].length;				path[cur_id]=v;			}			else if(vec_Node[cur_id].totalDis==vec_Node[v].totalDis+graph[v][i].length){		        if(flag){					path[cur_id]=v;				}	 		    }	    }	}}int findUnvisitedTime(){	bool firstCmp=true;	int minTime=-1;	int minV=-1;	for(int i=0;i<vec_Node.size();i++){		if(vec_Node[i].visited==false&&firstCmp){			firstCmp=false;			minTime=vec_Node[i].timeCost;			minV=i;		}		else if(vec_Node[i].visited==false&&vec_Node[i].timeCost<minTime){			minTime=vec_Node[i].timeCost;			minV=i;		}	}	return minV;}void findShortestTime(int start,int end){	vec_Node[start].timeCost=0;	vec_Node[start].numNodes=0;	int v,w;	while(true){		v=findUnvisitedTime();		if(v==-1) break;		vec_Node[v].visited=true;		for(int i=0;i<graph[v].size();i++){			w=graph[v][i].id;			int flag=false;			if(vec_Node[w].numNodes>vec_Node[v].numNodes+1){				flag=true;				vec_Node[w].numNodes>vec_Node[v].numNodes+1;			}			if(vec_Node[w].timeCost>vec_Node[v].timeCost+graph[v][i].time){				vec_Node[w].timeCost=vec_Node[v].timeCost+graph[v][i].time;				timePath[w]=v;			}			else if(vec_Node[w].timeCost==vec_Node[v].timeCost+graph[v][i].time){			    if(flag){			    	timePath[w]=v;				}				}		}	}}void initTime(){	for(int i=0;i<vec_Node.size();i++){		vec_Node[i].timeCost=INFI;		vec_Node[i].visited=false;		vec_Node[i].numNodes=INFI;	} } int main(){	freopen("D:\\in.txt","r",stdin);	int n,m;	scanf("%d%d",&n,&m);	//vector<Edge> *graph=new vector<Edge>[n];	graph.resize(n);	vec_Node.resize(n);	path.resize(n);	timePath.resize(n);	initNode();	int v1,v2,oneWay,length,time;	int start,end;	Edge temp;	while(m--){		scanf("%d%d%d%d%d",&v1,&v2,&oneWay,&length,&time);	    temp.id=v2;		temp.length=length;		temp.time=time;		graph[v1].push_back(temp);		if(oneWay==0){			temp.id=v1;			graph[v2].push_back(temp);		}	}	scanf("%d%d",&start,&end);	path[start]=-1;	timePath[start]=-1;	findShortestPath(start,end);	int shortestDis=vec_Node[end].totalDis;	initTime();	findShortestTime(start,end);	stack<int> sta;	stack<int> sta_copy;	stack<int> staTime;	stack<int> staTime_copy;	int x=end;	while(x!=-1){		sta.push(x);		sta_copy.push(x);		x=path[x];	}	x=end;    while(x!=-1){    	staTime.push(x);    	staTime_copy.push(x);    	x=timePath[x];	}	bool isSame=true;	if(sta_copy.size()!=staTime_copy.size()) isSame=false;    else{    	while(!sta_copy.empty()&&!staTime_copy.empty()){    		if(sta_copy.top()!=staTime_copy.top()){    			isSame=false;    			break;			}			sta_copy.pop();			staTime_copy.pop();		 } 	}	if(isSame) printf("Distance = %d; ",shortestDis);	else{		printf("Distance = %d: %d",shortestDis,sta.top());		sta.pop();		while(!sta.empty()){			printf(" -> %d",sta.top());			sta.pop();		}			printf("\n");	}    printf("Time = %d: %d",vec_Node[end].timeCost,staTime.top());    staTime.pop();    while(!staTime.empty()){			printf(" -> %d",staTime.top());			staTime.pop();	}		printf("\n");	return 0;}/* 27/30 using dfs 27/30 2016-9-10  the day before PAT!*///pat 1111. Online Map (30)/* 27/30 3 points timeout.. */#include<iostream>#include<algorithm>#include<vector>#define MS 505#define INF 0xffffffusing namespace std;typedef struct Node{    int tt;    int td;    int nodes;}Node;typedef struct Edge{	int id;	int len;	int time;	Edge(int _id,int _len,int _t)	{		id=_id;		len=_len;		time=_t;	}}Edge;bool visited[MS];int n,s,des,m;vector<vector<Edge> >mmap(MS);vector<int> rest;vector<int> resd;int mt=INF;int md=INF;int mn;int mtt=INF;void init(){	for(int i=0;i<n;i++) visited[i]=false;}void dfs(int i,int sumt,int sumd,vector<int> &patht,int nodes){	if(sumt>mt&&sumd>md) return;	if(i==des)	{		if(sumt<mt)		{			mt=sumt;			rest=patht;			mn=nodes;		}		else if(sumt==mt)		{			if(nodes<mn)			{				rest=patht;				mn=nodes;			}		}		if(sumd<md)		{			mtt=sumt;			md=sumd;			resd=patht;		}		else if(sumd==md)		{			if(sumt<mtt)			{				resd=patht;				mtt=sumt;			}		}		return;	}	for(int j=0;j<mmap[i].size();j++)	{		int cur=mmap[i][j].id;		if(!visited[cur])		{			visited[cur]=true;			patht.push_back(cur);			dfs(cur,sumt+mmap[i][j].time,sumd+mmap[i][j].len,patht,nodes+1);			patht.pop_back();			visited[cur]=false;		}	}}int main(){	freopen("D:\\in.txt","r",stdin);	scanf("%d%d",&n,&m);	int ow,dis,time,from,to;	vector<int> patht;	init();	while(m--)	{		scanf("%d%d%d%d%d",&from,&to,&ow,&dis,&time);		mmap[from].push_back(Edge(to,dis,time));		if(ow==0) mmap[to].push_back(Edge(from,dis,time));	}	scanf("%d %d",&s,&des);	visited[s]=true;	dfs(s,0,0,patht,0);    if(rest==resd)	{		printf("Distance = %d; Time = %d:",md,mt);		printf(" %d",s);		for(int i=0;i<rest.size();i++) printf(" -> %d",rest[i]);		printf("\n");	}	else	{		printf("Distance = %d:",md);		printf(" %d",s);		for(int i=0;i<resd.size();i++) printf(" -> %d",resd[i]);		printf("\n");		printf("Time = %d:",mt);		printf(" %d",s);		for(int i=0;i<rest.size();i++) printf(" -> %d",rest[i]);		printf("\n");	}	return 0;}
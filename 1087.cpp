/* 1087. All Roads Lead to Rome (30) *//* starting at 2016-8-30 17:16 *//* 25/30 first submit time: 19:04 (hang out 30min) *//* can not find.. *//* you try to find the best path in one dijkstra *//* but there will be many problems,since you just want *//* find the maxinum happiness which is not suitable by using dijkstra *//* so the proper way to do this is to record all the possible  *//* smallest cost way and recompute the best answer. *//* using dijkstra and dfs. just redo it.~ *//* ***********Sample Input:6 7 HZHROM 100PKN 40GDN 55PRS 95BLN 80ROM GDN 1BLN ROM 1HZH PKN 1PRS ROM 2BLN HZH 2PKN GDN 1HZH PRS 1Sample Output:3 3 195 97HZH->PRS->ROM*****************/#include<iostream>#include<vector>#include<algorithm>#include<map>#include<stack>#include<string>#define INF 10000000using namespace std;typedef struct Edge{	int city; 	int dis;	Edge(int _city,int _dis)	{		city=_city;		dis=_dis;	}}Edge;typedef struct Node{	string name;	bool visited;	int tDis;	int happ;	int tHapp;	int tNodes;}Node;map<string,int> c2h;map<string,int> c2Id;vector<vector<Edge> > vec;vector<Node> cities;vector<int> path;int cnt=0;int findShortest(){	bool findFirst=false;	int minDis;	int minIndex=-1;	for(int i=0;i<cities.size();i++)	{		if(!findFirst&&cities[i].visited==false){			minDis=cities[i].tDis;			minIndex=i;			findFirst=true;		}		else if(findFirst&&cities[i].visited==false){			if(cities[i].tDis<minDis){				minDis=cities[i].tDis;				minIndex=i;			}		}	}	return minIndex;}void dijkstra(int rom){	int v,w;	while(true){	   v=findShortest();	   //cout<<"this is v"<<v<<endl;       if(v==-1) break;       cities[v].visited=true;       for(int i=0;i<vec[v].size();i++)	   {		   w=vec[v][i].city;		   if(cities[w].tDis>cities[v].tDis+vec[v][i].dis)		   {			   cities[w].tDis=cities[v].tDis+vec[v][i].dis;			   cities[w].tHapp=cities[v].tHapp+cities[w].happ;			   cities[w].tNodes=cities[v].tNodes+1;			   path[w]=v;			   if(w==rom) cnt=1;		   }		   else if(cities[w].tDis==cities[v].tDis+vec[v][i].dis)		   {			    if(w==rom) cnt++;			    if(cities[w].tHapp<cities[v].tHapp+cities[w].happ)			    {				   cities[w].tHapp=cities[v].tHapp+cities[w].happ;				   cities[w].tNodes=cities[v].tNodes+1;				   path[w]=v;			    }			    else if(cities[w].tHapp==cities[v].tHapp+cities[w].happ)			    {				   if(cities[w].tNodes>cities[v].tNodes+1)				   {					   cities[w].tNodes=cities[v].tNodes+1;					   path[w]=v;				   }			    }		   }	   }		   	}	}int main(){	freopen("D:\\in.txt","r",stdin);	int n,k,happ;    string start,city;    cin>>n>>k>>start;	cities.resize(n);	path.resize(n);	vec.resize(n);	c2Id[start]=0;	cities[0].visited=false;	cities[0].tDis=0;	cities[0].tNodes=0;	cities[0].tHapp=0;	for(int i=1;i<n;i++)	{		cin>>city>>happ;		c2Id.insert(make_pair(city,i));		cities[i].name=city;		cities[i].visited=false;		cities[i].tDis=INF;		cities[i].happ=happ;		cities[i].tHapp=0;		cities[i].tNodes=INF;	}	string from,to;	int dis;	while(k--)	{		cin>>from>>to>>dis;		vec[c2Id[from]].push_back(Edge(c2Id[to],dis));		vec[c2Id[to]].push_back(Edge(c2Id[from],dis));	}	int rom=c2Id["ROM"];	dijkstra(rom);	stack<int> sta;	int cur=c2Id["ROM"];	while(cur!=0)	{		sta.push(cur);		cur=path[cur];	}		printf("%d %d %d %d\n",cnt,cities[rom].tDis,cities[rom].tHapp,cities[rom].tHapp/(cities[rom].tNodes));	cout<<start;	while(!sta.empty()){		cout<<"->";		cout<<cities[sta.top()].name;		sta.pop();	}	cout<<endl;	return 0;}/* accepted code from CSDN */#include <iostream>  #include <stdio.h>  #include <string>  #include <map>  #include <vector>  using namespace std;  #define MAX 66666666  #define SIZE 203  // output: number of routes,lowest cost, happiness,avgHap  vector<int> resPath;  int routeSum=0,shortest = MAX,resHap=0,avgHap = 0;  map<string,int> hapiness1;  map<int,string> hapiness2;  map<int,int> hapSet;  int graph[SIZE][SIZE];  int dij[SIZE];  int visit[SIZE];  int n,k;  void dfs(int start,int end,vector<int> &path,int hapSum,int pathSum);  void dijkstra(int s);    int main()  {      int i,j,index1,tmp1,tmp2,tmp3;      int dest = 0;      string city1,city2,city3,city4;      cin>>n>>k>>city1;      index1= 0;      hapiness1[city1] = index1;      hapiness2[index1] = city1;      hapSet[index1] = 0;      for(i=1;i<n;i++)      {          cin>>city2>>tmp1;          if(city2.compare("ROM")==0)          {              dest = i;          }          hapiness1[city2] = i;          hapiness2[i] = city2;          hapSet[i] = tmp1;      }      for(i=0;i<n;i++)      {          dij[i] = MAX;          for(j=0;j<n;j++)          {              graph[i][j] = MAX;          }      }      for(i=0;i<k;i++)      {          cin>>city2>>city3>>tmp1;          tmp2 = hapiness1[city2];          tmp3 = hapiness1[city3];          if(tmp1<graph[tmp2][tmp3])          {              graph[tmp2][tmp3] = tmp1;              graph[tmp3][tmp2] = tmp1;          }      }    dijkstra(0);      for(i=0;i<n;i++)      {          visit[i] = 0;      }      shortest = dij[dest];      vector<int> myPath(1,0);      visit[0] = 1;      dfs(0,dest,myPath,0,0);      printf("%d %d %d %d\n",routeSum,shortest,resHap,avgHap);      cout<<city1;      for(i=1;i<resPath.size();i++)      {          cout<<"->"<<hapiness2[resPath[i]];      }      cout<<endl;      return 0;  }    void dfs(int start,int end,vector<int> &path,int hapSum,int pathSum)  {      int i,j;      if(pathSum>shortest)      {          return ;      }      if(start==end)      {          if(pathSum>shortest)          {              return ;          }          routeSum ++;          if(hapSum<resHap)          {              return ;          }          int ta = hapSum/(path.size()-1);          if(ta>avgHap)          {              resPath = path;              avgHap = ta;              resHap = hapSum;          }          return ;      }      for(i=0;i<n;i++)      {          if(!visit[i] && graph[start][i]!=MAX)          {              path.push_back(i);              visit[i] = 1;              dfs(i,end,path,hapSum + hapSet[i],pathSum+graph[start][i]);              path.pop_back();              visit[i] = 0;          }      }  }  //6:52 ->6:58  void dijkstra(int s)  {      int i,j,tmp,so;      for(i=0;i<n;i++)      {          dij[i] = graph[s][i];          visit[i] = 0;      }      dij[s] = 0;      visit[s] = 1;            for(i=1;i<n;i++)      {          tmp = MAX;          so = s;          for(j=0;j<n;j++)          {              if(!visit[j] && dij[j]<tmp)              {                  tmp = dij[j];                  so = j;              }          }          visit[so] = 1;          for(j=0;j<n;j++)          {              if(!visit[j] && dij[so]+graph[so][j]<dij[j])              {                  dij[j] = dij[so]+graph[so][j];              }          }      }      }  
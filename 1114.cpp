/* Family Poperity *//* PAT ID:1114 *//* 2016-8-3 *//* out of memory and multi mistakes  *//* such code is discarded...*//* learn about other's thinking and rewrite it. */#include<iostream>#include<vector>#include<algorithm>#include<map>#include<set>#define MAX_SIZE 10000using namespace std;int idSet[MAX_SIZE];typedef struct Info{	int id;	int M_estate;	int Area;}Info;typedef struct Result{	int totalMember;	int minMemberID;	float total_m;	float total_a;}Result;void initSet(){	for(int i=0;i<MAX_SIZE;i++)		idSet[i]=i;}void CompressSet(int top, int x)  {      if(idSet[x]!= top)      {          CompressSet(top,idSet[x]);        idSet[x]=top;		    }  } int Find(int x){	if(idSet[x]==x){		return x;	}	else{			int top = Find(idSet[x]);		CompressSet(top,x);	}	return idSet[x];}void Union(int root1,int root2){	int a =Find(root1);	int b=Find(root2);	idSet[a]=b;}bool cmp(const Result &a,const Result &b){	return (a.total_a)/(a.totalMember)>(b.total_a)/(b.totalMember);}int main(){	int n;	freopen("D:\\in.txt","r",stdin);	vector<Info> vec;	initSet();	scanf("%d",&n);	vec.resize(n);	int id,m_id,f_id,numChild,childId;	map<int,int>id2Add;	for(int i=0;i<n;i++){		scanf("%d",&vec[i].id);		id2Add.insert(make_pair(vec[i].id,i));		scanf("%d",&f_id);		if(f_id!=-1){			Union(f_id,vec[i].id);		}		scanf("%d",&m_id);		if(m_id!=-1){			Union(m_id,vec[i].id);		}		scanf("%d",&numChild);		while(numChild--){			scanf("%d",&childId);			Union(childId,vec[i].id);		}		scanf("%d%d",&vec[i].M_estate,&vec[i].Area);	}	vector<Result> res;	Result res_temp;	set<int> exitsSet;	for(int i=0;i<n;i++){		int id=Find(vec[i].id);		res_temp.totalMember=0;	    res_temp.total_a=0;	    res_temp.total_m=0;	    res_temp.minMemberID=99999;		set<int>::iterator iter;		iter=exitsSet.find(id);		if(iter==exitsSet.end()){			exitsSet.insert(id);			for(int i=0;i<MAX_SIZE;i++){				if(idSet[i]==id){					map<int,int>::iterator iter2;					iter2=id2Add.find(i);					if(iter2!=id2Add.end()){						res_temp.total_a+=vec[iter2->second].Area;						res_temp.total_m+=vec[iter2->second].M_estate;					}					res_temp.totalMember++;					if(i<res_temp.minMemberID) res_temp.minMemberID=i;				}			}			res.push_back(res_temp);		}	}	sort(res.begin(),res.end(),cmp);	for(int i=0;i<MAX_SIZE;i++) cout<<idSet[i]<<"--";	cout<<endl;	vector<Result>::iterator iter3=res.begin();	printf("%d\n",res.size());	for(;iter3!=res.end();iter3++){		printf("%04d %d %.3f %.3f\n",iter3->minMemberID,iter3->totalMember,1.0*(iter3->total_m)/(iter3->totalMember),1.0*(iter3->total_a)/(iter3->totalMember));			}	return 0;}/* the following version is Accepted by your own *//* Family Poperity *//* PAT ID:1114 *//* 2016-8-3 *//* the use of union-find set(also called the disjoint set)*//* the main thinking: we use a vector vec to store every single information *//* of a person's property,we do not store his/her family member's infromation*//* in the vector,we use a disjoint set to mark the relationship graph.in the same *//* time when we input data,we simply use a set named totalID to mark all the members' ID*//* that appears in the input. by traverse the totalID set, and execute the find method*//* we can store get the map<int,vector<int> > data structure which the key value *//* marks the top element in the disjoint set and the vector<int> store all the family *//* members' ID information. get the total estate,sort them will be simple later*/#include<iostream>#include<vector>#include<algorithm>#include<map>#include<set>#define MAX_SIZE 10000using namespace std;int idSet[MAX_SIZE];set<int> totalID;typedef struct Info{	int id;	int M_estate;	int Area;}Info;typedef struct Result{	int totalMember;	int minMemberID;	float total_m;	float total_a;}Result;/* this is just the union-find set's core algorithm */void initSet(){	for(int i=0;i<MAX_SIZE;i++)		idSet[i]=i;}void CompressSet(int top, int x)  {      if(idSet[x]!= top)      {          CompressSet(top,idSet[x]);        idSet[x]=top;		    }  } int Find(int x){	if(idSet[x]==x){		return x;	}	else{			int top = Find(idSet[x]);		CompressSet(top,x);		//return idSet[x]=Find(idSet[x]);	}    return idSet[x];}void Union(int root1,int root2){	int a =Find(root1);	int b=Find(root2);	idSet[a]=b;}/* which family's average room is larger,which one should print first *//* if there is a tie,whose minMemberID smaller whill be printed first. */bool cmp(const Result &a,const Result &b){	if(((a.total_a)/(a.totalMember))!=((b.total_a)/(b.totalMember))){		return ((a.total_a)/(a.totalMember))>((b.total_a)/(b.totalMember));	}	else return a.minMemberID<b.minMemberID;}int main(){	int n;	freopen("D:\\in.txt","r",stdin);	vector<Info> vec;	initSet();	scanf("%d",&n);	vec.resize(n);	int id,m_id,f_id,numChild,childId;	map<int,int>id2Add;	for(int i=0;i<n;i++){		scanf("%d",&vec[i].id);		totalID.insert(vec[i].id);		id2Add.insert(make_pair(vec[i].id,i));		scanf("%d",&f_id);		if(f_id!=-1){			totalID.insert(f_id);			Union(f_id,vec[i].id);		}		scanf("%d",&m_id);		if(m_id!=-1){			totalID.insert(m_id);			Union(m_id,vec[i].id);		}		scanf("%d",&numChild);		while(numChild--){			scanf("%d",&childId);			totalID.insert(childId);			Union(childId,vec[i].id);		}		scanf("%d%d",&vec[i].M_estate,&vec[i].Area);	}	vector<Result> res;	Result res_temp;	set<int>::iterator iter;	map<int,vector<int> > m_list;	map<int,vector<int> >::iterator iter_temp;    for(iter=totalID.begin();iter!=totalID.end();iter++){		int root=Find(*iter);		//cout<<"this is : "<<*iter<<endl;		iter_temp=m_list.find(root);		//cout<<"this is root:"<<root<<endl;		if(iter_temp==m_list.end()){			vector<int> vec_temp;			m_list.insert(make_pair(root,vec_temp));			m_list[root].push_back(*iter);		}		else{			m_list[root].push_back(*iter);		}	}	map<int,vector<int> >::iterator iter2;	for(iter2=m_list.begin();iter2!=m_list.end();iter2++){		vector<int>::iterator iter4;		res_temp.totalMember=0;		res_temp.total_a=0;		res_temp.total_m=0;		res_temp.minMemberID=9999;		for(iter4=(iter2->second).begin();iter4!=(iter2->second).end();iter4++){			map<int,int>::iterator iter5;			res_temp.totalMember++;			if(res_temp.minMemberID>(*iter4)) res_temp.minMemberID=*iter4;			iter5=id2Add.find(*iter4);			if(iter5!=id2Add.end()){			   res_temp.total_m+=vec[id2Add[*iter4]].M_estate;			   res_temp.total_a+=vec[id2Add[*iter4]].Area;			}		}		res.push_back(res_temp);	}	sort(res.begin(),res.end(),cmp);	vector<Result>::iterator iter3=res.begin();	printf("%d\n",res.size());	for(;iter3!=res.end();iter3++){		printf("%04d %d %.3f %.3f\n",iter3->minMemberID,iter3->totalMember,1.0*(iter3->total_m)/(iter3->totalMember),1.0*(iter3->total_a)/(iter3->totalMember));			}	return 0;}/* 2016-9-10 Accepted! *///1114. Family Property (25)#include<vector>#include<algorithm>#include<iostream>#include<map>#include<set>#define MS 10005using namespace std;typedef struct Ans{	int id;	int num;	int te;	float ta;	float ave;}Ans;typedef struct Node{	int parent;    float ta;	int te;}Node;bool cmp(const Ans &a,const Ans &b ){	if(a.ave!=b.ave) return a.ave>b.ave;	else return a.id<b.id;}vector<Node> vec(MS);int n;void init(){	for(int i=0;i<=MS;i++)	{		vec[i].parent=i;		vec[i].ta=0;		vec[i].te=0;	}} int Find(int a){	if(a!=vec[a].parent)	{		return vec[a].parent=Find(vec[a].parent);	}	else return a;}void Union(int a,int b){	int x=Find(a);	int y=Find(b);	x>y?vec[x].parent=y:vec[y].parent=x;}int main(){  freopen("D:\\in.txt","r",stdin);  scanf("%d",&n);  set<int> mset;  init();  while(n--)  {  	int id,fid,mid,num,cid;  	int num2;  	float area;  	vector<int> temp;  	scanf("%d",&id);  	temp.push_back(id);  	scanf("%d%d%d",&fid,&mid,&num);  	if(fid!=-1) temp.push_back(fid);  	if(mid!=-1) temp.push_back(mid);  	while(num--)  	{  		scanf("%d",&cid);  		temp.push_back(cid);	}	scanf("%d %f",&num2,&area);	sort(temp.begin(),temp.end());	vec[temp[0]].te+=num2;	vec[temp[0]].ta+=area;	mset.insert(temp[0]);	for(int i=1;i<temp.size();i++)	{	    Union(temp[i],temp[0]);	    mset.insert(temp[i]);	}  }	  set<int>::iterator iter=mset.begin();   vector<Ans> res;  map<int,Ans> mmap;  set<int> fam;  set<int>::iterator iter2;  for(;iter!=mset.end();iter++)  {     int par=Find(*iter);     mmap[par].ta+=vec[*iter].ta;	 mmap[par].te+=vec[*iter].te; 	 mmap[par].id=par;	 mmap[par].num++;  }  map<int,Ans>::iterator iter3=mmap.begin();  vector<Ans> ans;  for(;iter3!=mmap.end();iter3++)  {  	iter3->second.ave=(iter3->second.ta)/(iter3->second.num);  	ans.push_back((*iter3).second);  }  sort(ans.begin(),ans.end(),cmp);  printf("%d\n",ans.size());  for(int i=0;i<ans.size();i++)  {	float avea,avee;	avea=ans[i].ave;	avee=ans[i].te*1.0/ans[i].num;  	printf("%04d %d %.3f %.3f\n",ans[i].id,ans[i].num,avee,avea);  }  return 0;}
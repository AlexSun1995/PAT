/* Wating in Line patID:1014 *//* starting time:2016-6-3 19:52 *//* fitst submit time:2016-6-3 22:01  *//* 19/30 multi mistakes *//* 2016-6-4 10:52 AC,axiba~ be careful!! *//* 题目 ！题目说的是17:00之前能排到。。。。 */#include<iostream>#include<queue>using namespace std;typedef struct Custom{	int spend;	int endMin;}Custom;void Min2Clock(int num1,int num2){ 	int hour,min;	hour=num2/60;	min=num2%60;	hour+=8;	if(num1>=540){		cout<<"Sorry"<<endl;	}	else printf("%02d:%02d\n",hour,min);}int main(){ 	//freopen("D:\\in.txt","r",stdin);	//n.num of windows,m.capacity of each inside yellow line.    //num of customs,num of queriers		int n,m,k,q;	cin>>n>>m>>k>>q;	Custom* customs=new Custom[k];	for(int i=0;i<k;i++){		cin>>customs[i].spend;	}	queue<int> *lines=new queue<int>[n];	int *linecount=new int[n];	for(int i=0;i<n;i++) linecount[i]=0;	//first time flag.	bool flag=false;	for(int i=0;i<k;i++){		int minLen=lines[0].size();		int minLenIndex=0;		for(int j=0;j<n;j++){			if(lines[j].size()<m&&lines[j].size()<minLen){				 minLen=lines[j].size();				 minLenIndex=j;			}		}		if(minLen<m){			lines[minLenIndex].push(i);			//cout<<"ok,we push: "<<i<<" in line: "<<minLenIndex<<endl;			flag=true;		}else{			flag=false;		}		if(!flag){			int minIndex=0;			int min=customs[lines[0].front()].spend+linecount[0];			for(int t=0;t<n;t++){				if(customs[lines[t].front()].spend+linecount[t]<min){				min=customs[lines[t].front()].spend+linecount[t];				minIndex=t;			   }		   }		linecount[minIndex]+=customs[lines[minIndex].front()].spend;		customs[lines[minIndex].front()].endMin=linecount[minIndex];		//cout<<"in line: "<<minIndex<<" we pop:"<<lines[minIndex].front()<<endl;		lines[minIndex].pop();		lines[minIndex].push(i);		//cout<<"ok,we push: "<<i<<" in line: "<<minIndex<<endl;	   }			}	for(int t=0;t<n;t++){		//cout<<"ha?"<<endl;		while(!lines[t].empty()){			linecount[t]+=customs[lines[t].front()].spend;		    customs[lines[t].front()].endMin=linecount[t];			//cout<<"lines[t]'s size "<<lines[t].size()<<endl;			lines[t].pop();		}	}		int temp;	while(q--){		cin>>temp;		Min2Clock(customs[temp-1].endMin-customs[temp-1].spend,customs[temp-1].endMin);	}	return 0;}
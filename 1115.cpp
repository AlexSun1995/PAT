/* 	PAT 1115 Counting Nodes In A BST *//* starting time: 2016-8-4 19:53*//* ACCEPTED 20:44 */#include<iostream>#include<queue>#include<stack>#include<algorithm>using namespace std;typedef struct Node{	int key;	Node *left;	Node *right;	int level;}Node;vector<int> result;bool cmp(const int &a,const int &b){	return a>b;}Node *initTree(int key,int level){	Node *tree;	tree=(Node *)malloc(sizeof(Node));    tree->level=level;    tree->left=NULL;    tree->right=NULL;		tree->key=key;	return tree;}void insert(Node* &head,int key){	if(key<=head->key){		if(head->left==NULL){			head->left=initTree(key,head->level+1);		}		else insert(head->left,key);	}	else if(key>head->key){		if(head->right==NULL){			head->right=initTree(key,head->level+1);		}		else insert(head->right,key);	}}void bfs(Node* &tree){	queue<Node*> que;	que.push(tree);	while(!que.empty()){		Node *temp=que.front();		result.push_back(temp->level);		//cout<<"level see:"<<temp->level<<endl;		if(temp->left){       			que.push(temp->left);		}		if(temp->right){			que.push(temp->right);		}		que.pop();	}}int main(){	//freopen("D:\\in.txt","r",stdin);	int n;	scanf("%d",&n);	vector<int> vec(n);	for(int i=0;i<n;i++) scanf("%d",&vec[i]);	Node *tree=initTree(vec[0],0);	for(int i=1;i<n;i++){		insert(tree,vec[i]);	}	bfs(tree);	sort(result.begin(),result.end(),cmp);	int n1,n2;  // n1 the num of the lowest level nodes	int first,second;	first=result[0];	n1=n2=0;	bool flag=true;	for(int i=0;i<result.size();i++){		if(result[i]==first) n1++;		else if(result[i]!=first&&flag){			second=result[i];			n2++;			flag=false;		}		else if(result[i]==second){			n2++;		}		else break;	}	printf("%d + %d = %d\n",n1,n2,n1+n2);	return 0;}